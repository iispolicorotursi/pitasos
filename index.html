<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PitaSOS</title>

    <!-- Bootstrap -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    />

    <!-- Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

    <style>
      body {
        font-family: "Nunito", sans-serif;
        background-color: #f8f9fa;
        padding: 1rem;
      }
      .main-container {
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        text-align: center;
        font-weight: 700;
        color: #0d6efd;
        margin-bottom: 1.5rem;
      }
      .card {
        border-radius: 1rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
      }
      .table th,
      .table td {
        vertical-align: middle !important;
      }
      .table thead th {
        white-space: nowrap;
      }
      .teacher-cell {
        width: 240px;
      }
      .hour-col {
        width: 130px;
        text-align: center;
      }
      .hour-col .form-select,
      .hour-col .form-control {
        text-align: left;
      }
      .comp-text,
      .perm-text {
        color: #6c757d;
        font-style: italic;
        text-align: center;
      }
      .select-pot {
        min-width: 150px;
      }
      .class-label {
        font-size: 0.8em;
        font-weight: 700;
        color: #6c757d;
        display: block;
        text-align: center;
        margin-bottom: 0.25rem;
      }
      .sticky-helpers {
        position: sticky;
        top: 0;
        z-index: 5;
        background: #f8f9fa;
        padding-top: 0.25rem;
      }
      .search-input {
        max-width: 420px;
      }
      .muted-badge {
        font-size: 0.8rem;
      }
      .toast-like {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 9999;
        min-width: 280px;
      }

      .is-invalid {
        border-color: #dc3545 !important;
        box-shadow: 0 0 0 0.15rem rgba(220, 53, 69, 0.25) !important;
      }
      td.needs-attention {
        background-color: #fff3f3 !important; /* leggero rosato */
      }

      /* Evidenziazione campi non compilati */
      td.needs-attention {
        background-color: #fff3cd !important; /* giallo Bootstrap warning */
        transition: background-color 0.4s ease;
      }

      select.is-invalid,
      input.is-invalid {
        border-color: #dc3545 !important; /* rosso Bootstrap danger */
        box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
      }

      /* effetto leggero quando l'utente rivede i campi */
      .bg-warning-subtle {
        background-color: #fff8e1 !important;
      }

      /* Evidenziazione campi non compilati */
      td.needs-attention {
        background-color: #fff3cd !important; /* giallo warning */
        transition: background-color 0.4s ease;
      }

      select.is-invalid,
      input.is-invalid {
        border-color: #dc3545 !important; /* rosso Bootstrap danger */
        box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
      }

      .bg-warning-subtle {
        background-color: #fff8e1 !important;
      }
    </style>
  </head>
  <body>
    <div class="main-container">
      <!-- Intestazione -->
      <div class="text-center mt-4 mb-4">
        <i
          class="bi bi-person-lines-fill text-primary"
          style="font-size: 3rem"
        ></i>
        <h1 class="fw-bold mb-1 mt-2">PitaSOS</h1>
        <p class="text-muted fst-italic mb-0">
          Versione per chi si occupa delle sostituzioni
        </p>
      </div>

      <!-- Selezione Data -->
      <div class="card mb-3">
        <div class="card-header bg-primary text-white fw-semibold">
          1. Seleziona la data
        </div>
        <div class="card-body">
          <div class="d-flex flex-column flex-md-row align-items-md-end gap-3">
            <div class="flex-fill">
              <label for="date-input" class="form-label fw-semibold"
                >Data:</label
              >
              <input type="date" class="form-control" id="date-input" />
            </div>
            <div>
              <button id="load-btn" class="btn btn-primary px-4">
                <i class="bi bi-arrow-repeat"></i> Ricarica / Ripristina
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- SEZIONE 1: Scelta assenti in pagina -->
      <div class="card mb-4">
        <div class="card-header bg-secondary text-white fw-bold">
          2. Seleziona i docenti assenti (in pagina)
        </div>
        <div class="card-body">
          <div class="row g-4">
            <!-- Assenze giornaliere -->
            <div class="col-lg-6">
              <h5 class="fw-bold mb-2">Assenze giornaliere</h5>
              <div class="sticky-helpers d-flex align-items-center gap-2 mb-2">
                <input
                  id="search-daily"
                  type="search"
                  class="form-control form-control-sm search-input"
                  placeholder="Cerca docente..."
                />
              </div>
              <div
                id="daily-absent-list"
                class="border rounded p-2"
                style="max-height: 340px; overflow: auto"
              ></div>
            </div>

            <!-- Assenze orarie -->
            <div class="col-lg-6">
              <h5 class="fw-bold mb-2">Assenze orarie</h5>
              <div class="sticky-helpers d-flex align-items-center gap-2 mb-2">
                <select
                  id="hourly-teacher-select"
                  class="form-select form-select-sm search-input"
                ></select>
                <span class="badge text-bg-light muted-badge">
                  <i class="bi bi-clock-history me-1"></i> Seleziona il docente
                  e spunta le ore di assenza
                </span>
              </div>
              <div class="border rounded p-3">
                <div
                  class="row row-cols-2 row-cols-md-3 g-2"
                  id="hourly-hours-grid"
                >
                  <!-- check ore qui -->
                </div>
                <div class="mt-3 small text-muted" id="hourly-selection-hint">
                  Seleziona un docente dall‚Äôelenco per impostare le ore di
                  assenza.
                </div>
              </div>
              <div class="mt-3">
                <h6 class="fw-semibold">
                  Riepilogo assenze orarie selezionate
                </h6>
                <div
                  id="hourly-summary"
                  class="border rounded p-2"
                  style="max-height: 180px; overflow: auto"
                >
                  <span class="text-muted fst-italic">Nessuna selezione.</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- SEZIONE 2: Proposte sostituzioni + riepilogo + PDF -->
      <div id="results-container">
        <div class="alert alert-info text-center mb-0">
          I risultati verranno mostrati qui dopo la selezione degli assenti.
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // ====== COSTANTI E STATO ======
        const HOURS = [
          "08:00-09:00",
          "09:00-10:00",
          "10:00-11:00",
          "11:00-12:00",
          "12:00-13:00",
          "13:00-14:00",
        ];

        const BANNED = new Set([
          "COLLETTA O.",
          "RINA T.",
          "BRUNO E.",
          "BATTIFARANO C.",
        ]);

        const dateInput = document.getElementById("date-input");
        const loadBtn = document.getElementById("load-btn");
        const resultsContainer = document.getElementById("results-container");

        // Sezione 1
        const dailyListEl = document.getElementById("daily-absent-list");
        const searchDailyEl = document.getElementById("search-daily");
        const hourlySelectEl = document.getElementById("hourly-teacher-select");
        const hourlyGridEl = document.getElementById("hourly-hours-grid");
        const hourlyHintEl = document.getElementById("hourly-selection-hint");
        const hourlySummaryEl = document.getElementById("hourly-summary");

        const remoteBaseUrl = "https://progetti.antoniofittipaldi.it/";
        const csvDataPath = "pitasos/";
        const phpScriptUrl = remoteBaseUrl + "pitasos/salva_sostituzioni.php";

        const corsProxy = "https://api.allorigins.win/raw?url=";
        const orarioFile = "orario.csv";
        const abbrevMap = ["dom", "lun", "mar", "mer", "gio", "ven", "sab"];
        const giorniEstesi = [
          "Domenica",
          "Luned√¨",
          "Marted√¨",
          "Mercoled√¨",
          "Gioved√¨",
          "Venerd√¨",
          "Sabato",
        ];

        let scheduleData = []; // righe orario
        let allTeachers = []; // tutti i docenti (da orario)
        let dailyAbsent = new Set(); // assenti full day
        let hourlyAbsent = new Map(); // nome -> Set(ore)
        let restoring = false; // flag durante ripristino per evitare rimbalzi
        let restoredChoices = new Map();

        // Data odierna di default
        const oggi = new Date();
        dateInput.value = `${oggi.getFullYear()}-${String(
          oggi.getMonth() + 1
        ).padStart(2, "0")}-${String(oggi.getDate()).padStart(2, "0")}`;

        // ====== UTILS ======
        async function fetchCSV(url) {
          // 1) prova diretta
          try {
            const r = await fetch(url, { cache: "no-store" });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const txt = await r.text();
            // vuoto trattato come errore
            if (!txt || !txt.trim().length) throw new Error("empty");
            return txt;
          } catch {
            // 2) prova via proxy
            const p = await fetch(corsProxy + encodeURIComponent(url), {
              cache: "no-store",
            });
            if (!p.ok) throw new Error(`Proxy ${p.status}`);
            const txt = await p.text();
            if (!txt || !txt.trim().length) throw new Error("empty");
            return txt;
          }
        }

        async function loadOrario() {
          const text = await fetch(orarioFile, { cache: "no-store" }).then(
            (r) => r.text()
          );
          const lines = text.trim().split("\n");
          const headers = lines[0].split(",").map((h) => h.trim());
          scheduleData = lines.slice(1).map((line) => {
            const values = line.split(",");
            const obj = headers.reduce((o, h, i) => {
              o[h] = values[i] ? values[i].trim().replace(/^"|"$/g, "") : "";
              return o;
            }, {});
            // Riconosci lezioni POT in base al suffisso (P) nel campo Classe
            if (obj.Classe && /\(P\)\s*$/.test(obj.Classe)) {
              obj.Classe = obj.Classe.replace(/\(P\)\s*$/, "").trim(); // rimuovi (P) in visualizzazione
              obj.isPOT = true; // flag interno
            } else {
              obj.isPOT = false;
            }
            if (obj.Classe && /\(S\)\s*$/.test(obj.Classe)) {
              obj.Classe = obj.Classe.replace(/\(S\)\s*$/, "").trim(); // rimuovi (P) in visualizzazione
              obj.isSOSTEGNO = true; // flag interno
            } else {
              obj.isSOSTEGNO = false;
            }
            return obj;
          });

          const teacherNames = scheduleData
            .map((r) => (r.Docente || "").trim())
            .filter(Boolean);
          allTeachers = [...new Set(teacherNames)]
            .filter((n) => !BANNED.has(n))
            .sort((a, b) => a.localeCompare(b));
        }

        const normalizzaGiorno = (g) =>
          (g || "")
            .toString()
            .toLowerCase()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "");

        function sameName(a, b) {
          if (!a || !b) return false;
          return a.trim().toUpperCase() === b.trim().toUpperCase();
        }

        function isDailyAbsent(name) {
          for (const n of dailyAbsent) {
            if (sameName(n, name)) return true;
          }
          return false;
        }

        function isHourlyAbsentAt(name, hour) {
          for (const [n, set] of hourlyAbsent) {
            if (sameName(n, name) && set && set.has(hour)) return true;
          }
          return false;
        }

        // ‚¨áÔ∏è SUBITO DOPO sameName / isDailyAbsent / isHourlyAbsentAt
        function isAbsentAtHour(name, hour) {
          if (!name || !hour) return false;
          // assente tutto il giorno?
          if (isDailyAbsent(name)) return true;
          // assente proprio in quell‚Äôora?
          return isHourlyAbsentAt(name, hour);
        }

        // Ritorna le ore (array tipo ["08:00-09:00", ...]) in cui il docente √® a orario nel giorno scelto
        function getTeacherHoursOnDate(teacherName, selectedDateStr) {
          if (!Array.isArray(scheduleData) || !teacherName || !selectedDateStr)
            return [];
          const d = new Date(selectedDateStr);
          // Attenzione: la tua app usa spesso getUTCDay() per coerenza con i CSV
          const giorniEstesi = [
            "Domenica",
            "Luned√¨",
            "Marted√¨",
            "Mercoled√¨",
            "Gioved√¨",
            "Venerd√¨",
            "Sabato",
          ];
          const giornoEsteso = giorniEstesi[d.getUTCDay()];
          const wanted = [];

          for (const r of scheduleData) {
            if (!r) continue;
            const doc = (r.Docente || "").trim();
            const day = normalizzaGiorno(r.Giorno || "");
            if (doc === teacherName && day === normalizzaGiorno(giornoEsteso)) {
              const oi = (r.OraInizio || "").trim();
              const of = (r.OraFine || "").trim();
              if (oi && of) wanted.push(`${oi}-${of}`);
            }
          }
          // dedup + ordine per ora
          return [...new Set(wanted)].sort((a, b) => a.localeCompare(b));
        }

        function showToast(html, cls = "alert-success") {
          const div = document.createElement("div");
          div.className = `alert ${cls} text-center mt-3 fade show shadow toast-like`;
          div.innerHTML = html;
          document.body.appendChild(div);
          setTimeout(() => {
            div.classList.remove("show");
            div.classList.add("fade");
            setTimeout(() => div.remove(), 400);
          }, 3000);
        }

        // dopo la definizione di showToast(...)
        window.showToast = showToast;

        // ====== SEZIONE 1: BUILD UI ======
        function buildDailyList(filter = "") {
          const q = filter.trim().toLowerCase();
          const giornoEsteso =
            giorniEstesi[new Date(dateInput.value).getUTCDay()];
          const todayTeachers = [
            ...new Set(
              scheduleData
                .filter(
                  (r) =>
                    normalizzaGiorno(r.Giorno) ===
                    normalizzaGiorno(giornoEsteso)
                )
                .map((r) => (r.Docente || "").trim())
                .filter(Boolean)
            ),
          ]
            .filter((n) => !BANNED.has(n))
            .sort((a, b) => a.localeCompare(b));

          dailyListEl.innerHTML = "";
          todayTeachers
            .filter((n) => !q || n.toLowerCase().includes(q))
            .forEach((name, idx) => {
              const id = `daily-${idx}`;
              const checked = dailyAbsent.has(name) ? "checked" : "";
              const item = document.createElement("div");
              item.className = "form-check";
              item.innerHTML = `
              <input class="form-check-input daily-absent" type="checkbox" id="${id}" value="${name}" ${checked}>
              <label class="form-check-label" for="${id}">
                <i class="bi bi-person-fill text-primary me-1"></i>${name}
              </label>
            `;
              dailyListEl.appendChild(item);
            });

          // Bind event listeners
          dailyListEl.querySelectorAll(".daily-absent").forEach((cb) => {
            cb.addEventListener("change", () => {
              const name = cb.value;

              if (cb.checked) {
                dailyAbsent.add(name);
                // Rimuovi da orarie
                hourlyAbsent.delete(name);
                buildHourlyTeacherSelect();
                buildHourlyGrid(); // reset griglia ore
                renderHourlySummary();
              } else {
                dailyAbsent.delete(name);
                buildHourlyTeacherSelect();
              }

              if (!restoring) {
                // üîÑ salva le scelte correnti (select o input manuali)
                const currentChoices = new Map();
                document
                  .querySelectorAll("select.select-pot, input.manual-pot")
                  .forEach((el) => {
                    const key = `${el.dataset.absent}|${el.dataset.hour}`;
                    const value = el.value?.trim() || "";
                    if (value) currentChoices.set(key, value);
                  });

                // ricrea la sezione 2 (tabelle)
                renderSubstitutionTables();

                // üîÅ ripristina le scelte ancora valide
                // üîÅ ripristina le scelte salvate dove ancora valide **e aggiorna il riepilogo**
                // üîÅ ripristina le scelte salvate dove ancora valide **e aggiorna il riepilogo**
                currentChoices.forEach((val, key) => {
                  const [doc, ora] = key.split("|");
                  const sostituto = val?.trim();
                  if (!sostituto) return;

                  // ‚õî Se il sostituto √® (ora) assente proprio in QUELL‚ÄôORA, non reimpostarlo
                  if (isAbsentAtHour(sostituto, ora)) return;

                  const cell = document.querySelector(
                    `.table tbody tr td[data-hour="${ora}"][data-absent="${CSS.escape(
                      doc
                    )}"]`
                  );
                  if (!cell) return;

                  const sel = cell.querySelector("select.select-pot");
                  const manual = cell.querySelector("input.manual-pot");

                  if (
                    sel &&
                    [...sel.options].some(
                      (o) => o.value.trim() === sostituto && !o.disabled
                    )
                  ) {
                    sel.value = sostituto;
                    if (manual) {
                      manual.value = "";
                      manual.removeAttribute("value");
                    }
                    updateSummaryCell(doc, ora, sostituto, sel.dataset.class);
                  } else if (manual) {
                    // ‚ùå Non travasare nel manuale se l‚Äôopzione non √® pi√π valida
                    manual.value = "";
                    manual.removeAttribute("value");
                  }
                });

                // üîß aggiorna visibilit√† menu per ogni ora
                // aggiorna visibilit√† menu in base ai docenti assenti
                // üîß aggiorna solo i menu realmente presenti nella pagina
                document
                  .querySelectorAll("select.select-pot")
                  .forEach((sel) => {
                    const ora = sel.dataset.hour;
                    if (ora) refreshPotVisibilityForHour(ora);
                  });

                // üî• reset selezioni solo dove l'assente era scelto
                document
                  .querySelectorAll("select.select-pot")
                  .forEach((sel) => {
                    const val = sel.value.trim().toUpperCase();
                    if (val && dailyAbsent.has(val)) {
                      // Se il docente selezionato ora √® assente ‚Üí rimuovilo solo da qui
                      sel.value = "";
                      const td = sel.closest("td");
                      const absent = sel.dataset.absent;
                      const hour = sel.dataset.hour;
                      const cls = sel.dataset.class;
                      updateSummaryCell(absent, hour, "", cls);

                      // Non travasare nel manuale
                      const man =
                        sel.parentElement.querySelector("input.manual-pot");
                      if (man) {
                        man.value = "";
                        man.removeAttribute("value");
                      }

                      // Effetto visivo leggero
                      td?.classList.add("bg-warning-subtle");
                      setTimeout(
                        () => td?.classList.remove("bg-warning-subtle"),
                        1200
                      );
                    }
                  });

                // ‚ôªÔ∏è Se un docente torna presente, riabilita le sue opzioni nei menu
                // üîß aggiorna solo i menu realmente presenti nella pagina
                document
                  .querySelectorAll("select.select-pot")
                  .forEach((sel) => {
                    const ora = sel.dataset.hour;
                    if (ora) refreshPotVisibilityForHour(ora);
                  });
              }
            });
          });
        }

        function buildHourlyTeacherSelect() {
          const giornoEsteso =
            giorniEstesi[new Date(dateInput.value).getUTCDay()];
          const todayTeachers = [
            ...new Set(
              scheduleData
                .filter(
                  (r) =>
                    normalizzaGiorno(r.Giorno) ===
                    normalizzaGiorno(giornoEsteso)
                )
                .map((r) => (r.Docente || "").trim())
                .filter(Boolean)
            ),
          ]
            .filter((n) => !BANNED.has(n))
            .sort((a, b) => a.localeCompare(b));

          const available = todayTeachers.filter((n) => !dailyAbsent.has(n));

          hourlySelectEl.innerHTML =
            `<option value="">‚Äî Seleziona docente ‚Äî</option>` +
            available.map((n) => `<option value="${n}">${n}</option>`).join("");

          // se il docente selezionato era stato bannato o passato a daily absent, svuota griglia
          if (
            hourlySelectEl.value &&
            !available.includes(hourlySelectEl.value)
          ) {
            hourlySelectEl.value = "";
            buildHourlyGrid();
            renderHourlySummary();
          }
        }

        function buildHourlyGrid() {
          hourlyGridEl.innerHTML = "";
          const name = hourlySelectEl.value;
          if (!name) {
            hourlyHintEl.classList.remove("d-none");
            return;
          }
          hourlyHintEl.classList.add("d-none");

          // üî∏ Calcola solo le ore effettive del docente in quel giorno
          const allowedHours = getTeacherHoursOnDate(name, dateInput.value);

          // Se il docente non ha ore in orario in quel giorno
          if (allowedHours.length === 0) {
            hourlyGridEl.innerHTML = `<div class="text-muted fst-italic">Nessuna ora disponibile per questo docente nella data selezionata.</div>`;
            return;
          }

          const selectedSet = hourlyAbsent.get(name) || new Set();
          allowedHours.forEach((h, i) => {
            const id = `h-${i}`;
            const checked = selectedSet.has(h) ? "checked" : "";
            const box = document.createElement("div");
            box.className = "form-check";
            box.innerHTML = `
      <input class="form-check-input hourly-box" type="checkbox" id="${id}" data-teacher="${name}" data-hour="${h}" ${checked}>
      <label class="form-check-label" for="${id}">${h}</label>
    `;
            hourlyGridEl.appendChild(box);
          });

          // ‚úÖ Aggiungi listener ai checkbox delle ore
          hourlyGridEl.querySelectorAll(".hourly-box").forEach((cb) => {
            cb.addEventListener("change", () => {
              const who = cb.dataset.teacher;
              const hour = cb.dataset.hour;
              const set = hourlyAbsent.get(who) || new Set();

              if (cb.checked) set.add(hour);
              else set.delete(hour);
              if (set.size) hourlyAbsent.set(who, set);
              else hourlyAbsent.delete(who);

              renderHourlySummary();
              renderSubstitutionTables();

              if (!restoring) {
                // ‚úÖ Aggiorna solo la visibilit√† dei menu per quell‚Äôora
                refreshPotVisibilityForHour(hour);

                // ‚öôÔ∏è Se il docente segnato come assente era selezionato come sostituto in quell'ora,
                // rimuovilo SOLO da quei menu (senza toccare gli altri)
                document
                  .querySelectorAll(`select[data-hour='${hour}']`)
                  .forEach((sel) => {
                    const currentValue = sel.value.trim().toUpperCase();
                    if (currentValue === who.toUpperCase()) {
                      sel.value = "";
                      updateSummaryCell(
                        sel.dataset.absent,
                        hour,
                        "",
                        sel.dataset.class
                      );

                      const td = sel.closest("td");
                      if (td) {
                        td.classList.add("bg-warning-subtle");
                        setTimeout(
                          () => td.classList.remove("bg-warning-subtle"),
                          1000
                        );
                      }
                    }
                  });

                // üîÅ Ora ricostruiamo le tabelle mantenendo le scelte gi√† fatte
                const currentChoices = new Map();
                document
                  .querySelectorAll("select.select-pot, input.manual-pot")
                  .forEach((el) => {
                    const key = `${el.dataset.absent}|${el.dataset.hour}`;
                    const value = el.value?.trim() || "";
                    if (value) currentChoices.set(key, value);
                  });

                renderSubstitutionTables();

                // üîÅ Re-applica scelte dove ancora valide **e aggiorna il riepilogo**
                currentChoices.forEach((val, key) => {
                  const [doc, ora] = key.split("|");
                  const sostituto = val?.trim();
                  if (!sostituto) return;

                  // ‚õî Skip totale se il sostituto √® diventato assente in QUELL‚ÄôORA
                  const becameAbsent =
                    dailyAbsent.has(sostituto) ||
                    (hourlyAbsent.has(sostituto) &&
                      hourlyAbsent.get(sostituto).has(ora));
                  if (becameAbsent) return;

                  const cell = document.querySelector(
                    `.table tbody tr td[data-hour="${ora}"][data-absent="${CSS.escape(
                      doc
                    )}"]`
                  );
                  if (!cell) return;

                  const sel = cell.querySelector("select.select-pot");
                  const manual = cell.querySelector("input.manual-pot");

                  if (
                    sel &&
                    [...sel.options].some(
                      (o) => o.value.trim() === sostituto && !o.disabled
                    )
                  ) {
                    sel.value = sostituto;
                    if (manual) {
                      manual.value = "";
                      manual.removeAttribute("value");
                    }
                    updateSummaryCell(doc, ora, sostituto, sel.dataset.class);
                  } else if (manual) {
                    manual.value = "";
                    manual.removeAttribute("value");
                  }
                });

                // üîÅ Rinfresca i menu solo alla fine
                HOURS.forEach(refreshPotVisibilityForHour);
              }
            });
          });
        }

        function renderHourlySummary() {
          if (!hourlyAbsent.size) {
            hourlySummaryEl.innerHTML = `<span class="text-muted fst-italic">Nessuna selezione.</span>`;
            return;
          }
          const rows = [];
          Array.from(hourlyAbsent.keys())
            .sort((a, b) => a.localeCompare(b))
            .forEach((name) => {
              const ore = Array.from(hourlyAbsent.get(name)).sort((a, b) =>
                a.localeCompare(b)
              );
              rows.push(
                `<div><i class="bi bi-person-fill text-primary me-1"></i><strong>${name}</strong>: ${ore.join(
                  ", "
                )}</div>`
              );
            });
          hourlySummaryEl.innerHTML = rows.join("");
        }

        // Filtro ricerca giornalieri
        searchDailyEl.addEventListener("input", () => {
          buildDailyList(searchDailyEl.value);
        });
        hourlySelectEl.addEventListener("change", buildHourlyGrid);

        // ====== LOGICA COMPRESENZA E POT ======
        function potSlotsForDay(giornoEsteso) {
          return scheduleData.filter(
            (r) =>
              normalizzaGiorno(r.Giorno || "") ===
                normalizzaGiorno(giornoEsteso) &&
              r.isPOT === true &&
              !BANNED.has((r.Docente || "").trim())
          );
        }

        function teachersInClassAt(classe, oi, of, giornoEsteso) {
          return scheduleData.filter(
            (r) =>
              normalizzaGiorno(r.Giorno || "") ===
                normalizzaGiorno(giornoEsteso) &&
              (r.Classe || "").trim() === (classe || "").trim() &&
              r.OraInizio === oi &&
              r.OraFine === of
          );
        }

        // Verifica compresenza e regole (POT vs disciplinare)
        // Ritorna: {compresenza: bool, compresente: string|null, richiedeSostituto: bool}
        function checkCompresenza(
          classe,
          oi,
          of,
          docenteAssente,
          giornoEsteso
        ) {
          const all = teachersInClassAt(classe, oi, of, giornoEsteso);
          const others = all.filter(
            (t) => (t.Docente || "").trim() !== (docenteAssente || "").trim()
          );
          if (!others.length) {
            return {
              compresenza: false,
              compresente: null,
              richiedeSostituto: true,
            };
          }

          // Determina chi √® presente o assente tra i compresenti
          const othersPresent = others.filter((o) => {
            const nome = (o.Docente || "").trim();
            const fullDayAbsent = dailyAbsent.has(nome);
            const hourSet = hourlyAbsent.get(nome);
            const hourAbsent = hourSet ? hourSet.has(`${oi}-${of}`) : false;
            return !(fullDayAbsent || hourAbsent);
          });

          // Se almeno uno √® presente ‚Üí compresenza
          if (othersPresent.length) {
            // Regola speciale: se l‚Äôassente √® POT e c'√® un disciplinare presente ‚Üí non serve sostituzione
            const assenteRow = all.find(
              (r) => (r.Docente || "").trim() === (docenteAssente || "").trim()
            );
            const isAbsentPOT = !!(assenteRow && assenteRow.isPOT);
            const anyDiscPresent = othersPresent.some((r) => r.isPOT === false);
            if (isAbsentPOT && anyDiscPresent) {
              return {
                compresenza: true,
                compresente: (othersPresent[0].Docente || "").trim(),
                richiedeSostituto: false,
              };
            }
            return {
              compresenza: true,
              compresente: (othersPresent[0].Docente || "").trim(),
              richiedeSostituto: false,
            };
          }

          // Nessuno presente: tutti assenti in quell'ora
          // Regola: se in classe ci sono (POT + disciplinare) e sono entrambi assenti ‚Üí sostituisci solo disciplinare
          const hasDisc = all.some((r) => r.isPOT === false);
          const hasPOT = all.some((r) => r.isPOT === true);

          if (hasDisc && hasPOT) {
            // Se l‚Äôassente attuale √® POT, non richiedere sostituto (si coprir√† sul disciplinare)
            const current = all.find(
              (r) => (r.Docente || "").trim() === (docenteAssente || "").trim()
            );
            const isCurrentPOT = !!(current && current.isPOT);
            if (isCurrentPOT) {
              return {
                compresenza: false,
                compresente: null,
                richiedeSostituto: false,
              };
            } else {
              // Disciplinare assente: richiedi sostituto
              return {
                compresenza: false,
                compresente: null,
                richiedeSostituto: true,
              };
            }
          }

          // Se non √® una coppia classica, resta la regola base: se tutti assenti, richiede sostituto
          return {
            compresenza: false,
            compresente: null,
            richiedeSostituto: true,
          };
        }

        // ====== RIEPILOGO: cell update + visibilit√† per ora ======
        function updateSummaryCell(absent, hour, text, className) {
          const cell = document.querySelector(
            `#summary-grid tbody tr[data-absent="${CSS.escape(
              absent
            )}"] td[data-hour="${hour}"]`
          );
          if (!cell) return;
          if (!text) {
            if (
              !cell.dataset.comp &&
              !cell.dataset.pot &&
              !cell.dataset.permesso
            )
              cell.innerHTML = "";
            return;
          }
          const low = text.toLowerCase();
          if (low.includes("in compresenza")) {
            cell.innerHTML = `<em>${text}</em>`;
            cell.dataset.comp = "1";
            delete cell.dataset.pot;
            delete cell.dataset.permesso;
          } else if (low.includes("permesso orario")) {
            cell.innerHTML = `<em class="perm-text">Permesso orario</em>`;
            cell.dataset.permesso = "1";
            delete cell.dataset.comp;
            delete cell.dataset.pot;
          } else if (text.toUpperCase() === "POT") {
            cell.innerHTML = `<strong class="text-secondary">POT</strong>`;
            cell.dataset.pot = "1";
            delete cell.dataset.comp;
            delete cell.dataset.permesso;
          } else {
            // Sostituto con classe a capo
            const cls = className ? ` (${className})` : "";
            cell.innerHTML = `${text}${cls ? `<br>${cls}` : ""}`;
            delete cell.dataset.comp;
            delete cell.dataset.pot;
            delete cell.dataset.permesso;
          }
        }

        // üîí Disabilita un docente selezionato come sostituto in tutte le altre select della stessa ora
        function disableChosenSubstituteForHour(selectedName, hour) {
          if (!selectedName || !hour) return;

          // Scorri tutte le select della stessa ora
          document
            .querySelectorAll(`select[data-hour='${hour}']`)
            .forEach((sel) => {
              const nomeU = selectedName.trim().toUpperCase();
              // Se il valore della select √® gi√† selezionato, salta
              if (sel.value.trim().toUpperCase() === nomeU) return;

              sel.querySelectorAll("option").forEach((op) => {
                if (op.value.trim().toUpperCase() === nomeU) {
                  op.disabled = true;
                }
              });
            });
        }

        // üîì Riabilita un docente come sostituto nelle select della stessa ora se non √® pi√π usato altrove
        function reenableSubstituteIfFree(selectedName, hour) {
          if (!selectedName || !hour) return;

          const isStillUsed = Array.from(
            document.querySelectorAll(`select[data-hour='${hour}']`)
          ).some(
            (sel) =>
              sel.value.trim().toUpperCase() ===
              selectedName.trim().toUpperCase()
          );

          // Se non pi√π usato, riabilitalo
          if (!isStillUsed) {
            document
              .querySelectorAll(`select[data-hour='${hour}'] option`)
              .forEach((op) => {
                if (
                  op.value.trim().toUpperCase() ===
                  selectedName.trim().toUpperCase()
                ) {
                  op.disabled = false;
                }
              });
          }
        }

        function getSummaryCellName(td) {
          if (!td) return "";
          // Prende SOLO la prima riga (prima di <br>) e toglie eventuali " (CLASSE)"
          const raw = td.textContent ? td.textContent.trim() : "";
          const firstLine = raw.split("\n")[0].split("<br>")[0].trim();
          // se √® nel formato "NOME (CLASSE)" prendi solo NOME
          const nameOnly = firstLine.replace(/\s*\(.*?\)\s*$/, "").trim();
          return nameOnly.toUpperCase();
        }

        function refreshPotVisibilityForHour(hour) {
          const selects = document.querySelectorAll(
            `select[data-hour='${hour}']`
          );

          selects.forEach((sel) => {
            const currentValue = sel.value.trim();
            const absent = sel.dataset.absent;
            const classe = sel.dataset.class;

            // üîπ Rimuovi opzioni dei docenti bannati o assenti (anche se non hanno data-pot)
            sel.querySelectorAll("option").forEach((op) => {
              const nomeOpt = op.value.trim();
              if (!nomeOpt) return; // ignora l‚Äôopzione vuota ‚Äú‚Äî‚Äù
              const nomeU = nomeOpt.toUpperCase();
              const disabled =
                BANNED.has(nomeU) ||
                dailyAbsent.has(nomeOpt) ||
                (hourlyAbsent.has(nomeOpt) &&
                  hourlyAbsent.get(nomeOpt).has(hour));

              if (disabled) op.remove();
            });

            // üîπ Se il docente selezionato ora √® assente ‚Üí resetta solo questo menu
            if (currentValue) {
              const isNowAbsent =
                dailyAbsent.has(currentValue) ||
                (hourlyAbsent.has(currentValue) &&
                  hourlyAbsent.get(currentValue).has(hour));
              if (isNowAbsent) {
                sel.value = "";
                updateSummaryCell(absent, hour, "", classe);

                const man = sel.parentElement.querySelector("input.manual-pot");
                if (man) {
                  man.value = "";
                  man.removeAttribute("value");
                }

                const td = sel.closest("td");
                if (td) {
                  td.classList.add("bg-warning-subtle");
                  setTimeout(
                    () => td.classList.remove("bg-warning-subtle"),
                    800
                  );
                }
              }
            }

            // üîπ Ricrea le opzioni valide
            const giornoEsteso =
              giorniEstesi[new Date(dateInput.value).getUTCDay()];
            const existingNames = [...sel.options].map((o) =>
              o.value.trim().toUpperCase()
            );

            scheduleData
              .filter(
                (r) =>
                  normalizzaGiorno(r.Giorno) ===
                    normalizzaGiorno(giornoEsteso) &&
                  r.isPOT &&
                  `${r.OraInizio}-${r.OraFine}` === hour
              )
              .forEach((r) => {
                const nome = (r.Docente || "").trim();
                const nomeU = nome.toUpperCase();

                const isAbsent =
                  dailyAbsent.has(nome) ||
                  (hourlyAbsent.has(nome) && hourlyAbsent.get(nome).has(hour));
                if (
                  !BANNED.has(nomeU) &&
                  !isAbsent &&
                  !existingNames.includes(nomeU)
                ) {
                  const opt = document.createElement("option");
                  opt.value = nome;
                  opt.textContent = nome;
                  sel.appendChild(opt);
                }
              });
          });

          // üîÑ Pulisci riepilogo: se un docente appena diventato assente era l√¨, svuotalo
          document
            .querySelectorAll(`#summary-grid td[data-hour='${hour}']`)
            .forEach((td) => {
              const text = (td.textContent || "").trim();
              if (!text) return;
              const nameOnly = text.replace(/\s*\(.*?\)\s*$/, "").trim();
              if (
                dailyAbsent.has(nameOnly) ||
                (hourlyAbsent.has(nameOnly) &&
                  hourlyAbsent.get(nameOnly).has(hour))
              ) {
                td.innerHTML = "";
                delete td.dataset.comp;
                delete td.dataset.pot;
                delete td.dataset.permesso;
              }
            });
        }

        // =====================================================
        // üîç Verifica se un docente √® in compresenza in una data ora
        // =====================================================
        // =====================================================
        // üîç Verifica compresenza e casi speciali (compresenza reciproca)
        // =====================================================
        // =====================================================
        // üîç Verifica compresenza e casi speciali (compresenza reciproca)
        // =====================================================
        function isCompresenza(
          classe,
          oraInizio,
          oraFine,
          docente,
          giornoEsteso
        ) {
          const hourKey = `${oraInizio}-${oraFine}`;

          // tutti i docenti (oltre all'assente) presenti in quella classe/ora
          const compresenti = scheduleData.filter(
            (r) =>
              normalizzaGiorno(r.Giorno || "") ===
                normalizzaGiorno(giornoEsteso) &&
              (r.Classe || "").trim() === (classe || "").trim() &&
              r.OraInizio === oraInizio &&
              r.OraFine === oraFine &&
              (r.Docente || "").trim() !== (docente || "").trim()
          );

          if (compresenti.length === 0) {
            return {
              stato: false,
              compresente: null,
              reciproca: false,
              partner: [],
            };
          }

          const compresentiNomi = compresenti.map((r) =>
            (r.Docente || "").trim()
          );

          // assente "in quell'ora": assente giornaliero OPPURE assente orario su hourKey
          const isAbsentThisHour = (name) =>
            isDailyAbsent(name) ||
            (hourlyAbsent.has(name) && hourlyAbsent.get(name).has(hourKey));

          // 1) c'√® almeno un compresente presente in quell'ora?
          const presenti = compresentiNomi.filter((n) => !isAbsentThisHour(n));
          if (presenti.length > 0) {
            // c'√® compresenza ‚Üí nessuna sostituzione necessaria
            return {
              stato: true,
              compresente: presenti[0],
              reciproca: false,
              partner: [],
            };
          }

          // 2) tutti i compresenti sono assenti in quell'ora
          const tuttiAssenti = compresentiNomi.every(isAbsentThisHour);
          if (tuttiAssenti) {
            // compresenza "reciproca": entrambi (o tutti) assenti nella stessa ora
            return {
              stato: false,
              compresente: null,
              reciproca: true,
              partner: compresentiNomi, // serve a renderSubstitutionTables per il controllo condiviso
            };
          }

          // fallback: niente compresenza utile -> richiede sostituzione
          return {
            stato: false,
            compresente: null,
            reciproca: false,
            partner: [],
          };
        }

        // ====== RENDER SEZIONE 2 (tabelle + riepilogo) ======
        // =====================================================
        // üîß GENERAZIONE SEZIONE 2: Tabelle sostituzioni
        // =====================================================
        function renderSubstitutionTables(restored = restoredChoices) {
          resultsContainer.innerHTML = "";
          let html = "";

          // intestazione data
          const dateObj = new Date(dateInput.value);
          const g = String(dateObj.getDate()).padStart(2, "0");
          const m = String(dateObj.getMonth() + 1).padStart(2, "0");
          const a = dateObj.getFullYear();
          const giornoEsteso = giorniEstesi[dateObj.getUTCDay()];

          // -------------------------------
          // üìò SEZIONE ASSENZE GIORNALIERE
          // -------------------------------
          html += `
        <div class="card mb-4">
          <div class="card-header bg-primary text-white fw-bold">
            Assenze giornaliere ‚Äî ${g}/${m}/${a}
          </div>
          <div class="table-responsive">
            <table class="table table-striped table-hover mb-0 align-middle">
              <thead class="bg-primary text-white">
                <tr>
                  <th class="teacher-cell">Docente assente</th>
                  ${HOURS.map(
                    (h) => `<th class="hour-col text-center">${h}</th>`
                  ).join("")}
                </tr>
              </thead>
              <tbody>
        `;

          const giornalieri = Array.from(dailyAbsent);
          giornalieri.forEach((docente) => {
            html += `<tr><td><i class="bi bi-person-fill text-primary me-1"></i>${docente}</td>`;
            HOURS.forEach((hour) => {
              const lez = scheduleData.find(
                (r) =>
                  normalizzaGiorno(r.Giorno) ===
                    normalizzaGiorno(giornoEsteso) &&
                  (r.Docente || "").trim() === docente &&
                  `${r.OraInizio}-${r.OraFine}` === hour
              );

              if (!lez) {
                html += `<td data-hour="${hour}" data-absent="${docente}"></td>`;
                return;
              }

              if (lez.isSOSTEGNO) {
                html += `<td data-hour="${hour}" data-absent="${docente}">
              <div class="comp-text text-center">In compresenza</div>
           </td>`;
                return;
              }

              const classe = lez.Classe || "";
              const comp = isCompresenza(
                classe,
                lez.OraInizio,
                lez.OraFine,
                docente,
                giornoEsteso
              );

              if (comp.stato) {
                const label = `In compresenza${
                  comp.compresente ? `<br>(${comp.compresente})` : ""
                }`;
                html += `<td data-hour="${hour}" data-absent="${docente}">
                        <div class="comp-text text-center">${label}</div>
                      </td>`;
              } else if (comp.reciproca && comp.partner.length) {
                // caso compresenza reciproca ‚Üí controllo condiviso
                const sharedId = `shared-${classe}-${hour.replace(/:/g, "")}`;
                const potSlots = scheduleData.filter(
                  (p) =>
                    p.isPOT &&
                    normalizzaGiorno(p.Giorno) ===
                      normalizzaGiorno(giornoEsteso) &&
                    p.OraInizio === lez.OraInizio &&
                    p.OraFine === lez.OraFine &&
                    !BANNED.has((p.Docente || "").trim().toUpperCase())
                );

                html += `<td data-hour="${hour}" data-absent="${docente}">
                        <div class="class-label">${classe}</div>`;
                if (potSlots.length === 0) {
                  html += `<input type="text" class="form-control form-control-sm manual-pot shared-manual"
                                 placeholder="Manuale..." id="${sharedId}-manual"
                                 data-hour="${hour}" data-class="${classe}">
                       </td>`;
                } else {
                  html += `<select class="form-select form-select-sm select-pot shared-select"
                                id="${sharedId}" data-hour="${hour}" data-class="${classe}">
                          <option value="">‚Äî</option>
                          ${potSlots
                            .map(
                              (p) =>
                                `<option value="${p.Docente.trim()}">${p.Docente.trim()}</option>`
                            )
                            .join("")}
                        </select>
                        <input type="text" class="form-control form-control-sm mt-1 manual-pot shared-manual"
                               placeholder="Manuale..." id="${sharedId}-manual"
                               data-hour="${hour}" data-class="${classe}">
                      </td>`;
                }
              } else {
                // caso ordinario: select pot disponibili oppure manuale
                const potSlots = scheduleData.filter((r) => {
                  if (
                    normalizzaGiorno(r.Giorno) !==
                      normalizzaGiorno(giornoEsteso) ||
                    r.OraInizio !== lez.OraInizio ||
                    r.OraFine !== lez.OraFine ||
                    !r.isPOT
                  )
                    return false;
                  const nome = (r.Docente || "").trim().toUpperCase();
                  return !BANNED.has(nome) && !dailyAbsent.has(nome);
                });

                if (potSlots.length === 0) {
                  html += `<td data-hour="${hour}" data-absent="${docente}">
                          <div class="class-label">${classe}</div>
                          <input type="text" class="form-control form-control-sm manual-pot"
                                 placeholder="Manuale..."
                                 data-absent="${docente}" data-hour="${hour}" data-class="${classe}">
                        </td>`;
                } else {
                  html += `<td data-hour="${hour}" data-absent="${docente}">
                          <div class="class-label">${classe}</div>
                          <select class="form-select form-select-sm select-pot"
                                  data-absent="${docente}" data-hour="${hour}" data-class="${classe}">
                            <option value="">‚Äî</option>
                            ${potSlots
                              .map(
                                (p) =>
                                  `<option value="${p.Docente.trim()}">${p.Docente.trim()}</option>`
                              )
                              .join("")}
                          </select>
                          <input type="text" class="form-control form-control-sm mt-1 manual-pot"
                                 placeholder="Manuale..."
                                 data-absent="${docente}" data-hour="${hour}" data-class="${classe}">
                        </td>`;
                }
              }
            });
            html += "</tr>";
          });

          html += `</tbody></table></div></div>`;

          // -------------------------------
          // üìô SEZIONE ASSENZE ORARIE
          // -------------------------------
          html += `
        <div class="card mb-4">
          <div class="card-header bg-primary text-white fw-bold">
            Assenze orarie ‚Äî ${g}/${m}/${a}
          </div>
          <div class="table-responsive">
            <table class="table table-striped table-hover mb-0 align-middle">
              <thead class="bg-primary text-white">
                <tr>
                  <th class="teacher-cell">Docente assente</th>
                  ${HOURS.map(
                    (h) => `<th class="hour-col text-center">${h}</th>`
                  ).join("")}
                </tr>
              </thead>
              <tbody>
        `;

          hourlyAbsent.forEach((hoursSet, docente) => {
            html += `<tr><td><i class="bi bi-person-fill text-primary me-1"></i>${docente}</td>`;
            HOURS.forEach((hour) => {
              if (!hoursSet.has(hour)) {
                html += `<td data-hour="${hour}" data-absent="${docente}"></td>`;
                return;
              }

              const lez = scheduleData.find(
                (r) =>
                  normalizzaGiorno(r.Giorno) ===
                    normalizzaGiorno(giornoEsteso) &&
                  (r.Docente || "").trim() === docente &&
                  `${r.OraInizio}-${r.OraFine}` === hour
              );
              if (!lez) {
                html += `<td data-hour="${hour}" data-absent="${docente}"></td>`;
                return;
              }

              if (lez.isSOSTEGNO) {
                html += `<td data-hour="${hour}" data-absent="${docente}">
              <div class="comp-text text-center">In compresenza</div>
           </td>`;
                return;
              }

              const classe = lez.Classe || "";
              const comp = isCompresenza(
                classe,
                lez.OraInizio,
                lez.OraFine,
                docente,
                giornoEsteso
              );

              if (comp.stato) {
                const label = `In compresenza${
                  comp.compresente ? `<br>(${comp.compresente})` : ""
                }`;
                html += `<td data-hour="${hour}" data-absent="${docente}">
                        <div class="comp-text text-center">${label}</div>
                      </td>`;
              } else if (comp.reciproca && comp.partner.length) {
                const sharedId = `shared-${classe}-${hour.replace(/:/g, "")}`;
                const potSlots = scheduleData.filter(
                  (p) =>
                    p.isPOT &&
                    normalizzaGiorno(p.Giorno) ===
                      normalizzaGiorno(giornoEsteso) &&
                    p.OraInizio === lez.OraInizio &&
                    p.OraFine === lez.OraFine &&
                    !BANNED.has((p.Docente || "").trim().toUpperCase())
                );

                html += `<td data-hour="${hour}" data-absent="${docente}">
                        <div class="class-label">${classe}</div>`;
                if (potSlots.length === 0) {
                  html += `<input type="text" class="form-control form-control-sm manual-pot shared-manual"
                                 placeholder="Manuale..." id="${sharedId}-manual"
                                 data-hour="${hour}" data-class="${classe}">`;
                } else {
                  html += `<select class="form-select form-select-sm select-pot shared-select"
                                id="${sharedId}" data-hour="${hour}" data-class="${classe}">
                          <option value="">‚Äî</option>
                          ${potSlots
                            .map(
                              (p) =>
                                `<option value="${p.Docente.trim()}">${p.Docente.trim()}</option>`
                            )
                            .join("")}
                        </select>
                        <input type="text" class="form-control form-control-sm mt-1 manual-pot shared-manual"
                               placeholder="Manuale..." id="${sharedId}-manual"
                               data-hour="${hour}" data-class="${classe}">`;
                }
                html += `</td>`;
              } else {
                // per le orarie normali: campo manuale (come nel tuo file attuale)
                html += `<td data-hour="${hour}" data-absent="${docente}">
                        <div class="class-label">${classe}</div>
                        <input type="text" class="form-control form-control-sm manual-pot"
                               placeholder="Manuale..."
                               data-absent="${docente}" data-hour="${hour}" data-class="${classe}">
                      </td>`;
              }
            });
            html += "</tr>";
          });

          html += `</tbody></table></div></div>`;

          // -------------------------------
          // üìó SEZIONE RIEPILOGO
          // -------------------------------
          const allAbsent = [
            ...giornalieri,
            ...Array.from(hourlyAbsent.keys()),
          ].filter((v, i, a) => a.indexOf(v) === i);

          html += `
        <div class="card mb-4">
          <div class="card-header bg-success text-white fw-bold">Riepilogo Sostituzioni Selezionate</div>
          <div class="card-body p-3">
            <div class="table-responsive">
              <table class="table table-striped table-hover align-middle" id="summary-grid">
                <thead class="bg-success text-white">
                  <tr>
                    <th class="teacher-cell">Docente assente</th>
                    ${HOURS.map(
                      (h) => `<th class="hour-col text-center">${h}</th>`
                    ).join("")}
                  </tr>
                </thead>
                <tbody>
                  ${allAbsent
                    .map(
                      (nome) => `
                    <tr data-absent="${nome}">
                      <td>${nome}</td>
                      ${HOURS.map(
                        (h) =>
                          `<td data-hour="${h}" data-absent="${nome}" class="text-center"></td>`
                      ).join("")}
                    </tr>`
                    )
                    .join("")}
                </tbody>
              </table>
            </div>
            <div class="mt-3">
              <label for="notes" class="form-label fw-semibold">Note (opzionali)</label>
              <textarea id="notes" class="form-control" rows="3" placeholder="Scrivi eventuali note..."></textarea>
            </div>
            <div class="d-flex flex-column flex-md-row justify-content-center gap-3 mt-4">
              <button id="export-pdf-btn" class="btn btn-outline-success px-4 fw-semibold">
                <i class="bi bi-file-earmark-pdf-fill me-1"></i> Scarica PDF e Salva Riepilogo
              </button>
              <button id="reset-sost-btn" class="btn btn-outline-danger px-4 fw-semibold">
                <i class="bi bi-arrow-counterclockwise me-1"></i> Resetta selezioni
              </button>
            </div>
          </div>
        </div>`;

          resultsContainer.innerHTML = html;

          // =====================================================
          // üîÅ RIPRISTINO SCELTE SALVATE (select / manual / compresenza / POT / permesso)
          // =====================================================
          if (restored && restored.size > 0) {
            restored.forEach((entry, key) => {
              const [docenteAssente, ora] = key.split("|");
              const { Sostituto, Classe, Tipo } = entry;

              if (!HOURS.includes(ora)) return;

              // 1) Scrivi sempre nel riepilogo in base al tipo
              if (Tipo === "COMPRESENZA") {
                const label = `In compresenza${
                  Sostituto ? `<br>(${Sostituto})` : ""
                }`;
                updateSummaryCell(docenteAssente, ora, label, Classe);
                return;
              }
              if (Tipo === "POTENZIAMENTO") {
                updateSummaryCell(docenteAssente, ora, "POT", Classe);
                return;
              }
              if (Tipo === "PERMESSO_ORARIO") {
                updateSummaryCell(
                  docenteAssente,
                  ora,
                  "Permesso orario",
                  Classe
                );
                return;
              }

              // 2) Se c'√® un sostituto ‚Äúvero‚Äù, prova a rimetterlo in UI
              if (Sostituto) {
                const cell = document.querySelector(
                  `.table tbody tr td[data-hour="${ora}"][data-absent="${CSS.escape(
                    docenteAssente
                  )}"]`
                );
                // La cella pu√≤ non esistere se era compresenza con partner presente.
                if (cell) {
                  const sel = cell.querySelector("select.select-pot");
                  const manual = cell.querySelector("input.manual-pot");

                  // preferisci la select se ha l'opzione (non disabilitata), altrimenti manuale
                  if (
                    sel &&
                    [...sel.options].some(
                      (o) => o.value.trim() === Sostituto.trim() && !o.disabled
                    )
                  ) {
                    sel.disabled = false;
                    sel.value = Sostituto.trim();
                    if (manual) {
                      manual.value = "";
                      manual.removeAttribute("value");
                    }
                  } else if (manual) {
                    manual.value = Sostituto.trim();
                    if (sel) sel.disabled = false; // coerenza con digitazione manuale
                  }
                }
                // Aggiorna riepilogo comunque
                updateSummaryCell(docenteAssente, ora, Sostituto, Classe);
              }
            });
          }

          // ==========================================================
          // üîÑ Sync controlli condivisi (compresenza reciproca) + listeners normalizzati
          // ==========================================================
          document.querySelectorAll(".shared-select").forEach((sel) => {
            sel.addEventListener("change", () => {
              const id = sel.id;
              const val = sel.value.trim();
              const hour = sel.dataset.hour || "";
              const classe = sel.dataset.class || "";

              document.querySelectorAll(`#${id}`).forEach((peer) => {
                if (peer !== sel) peer.value = val;
                const peerManual =
                  peer.parentElement.querySelector(".shared-manual");
                if (peerManual) {
                  peerManual.value = "";
                  peerManual.removeAttribute("value");
                }

                const td = peer.closest("td[data-absent]");
                if (td) {
                  updateSummaryCell(td.dataset.absent, hour, val, classe);
                }
              });
            });
          });

          document.querySelectorAll(".shared-manual").forEach((inp) => {
            inp.addEventListener("input", () => {
              const id = inp.id.replace("-manual", "");
              const val = inp.value.trim();
              const hour = inp.dataset.hour || "";
              const classe = inp.dataset.class || "";

              document
                .querySelectorAll(`#${id}-manual`)
                .forEach((peerManual) => {
                  if (peerManual !== inp) peerManual.value = val;
                });
              document.querySelectorAll(`#${id}`).forEach((peerSelect) => {
                peerSelect.value = "";
              });

              const allPeers = [
                ...document.querySelectorAll(`#${id}-manual`),
                ...document.querySelectorAll(`#${id}`),
              ];
              const peerTds = new Set(
                allPeers
                  .map((el) => el.closest("td[data-absent]"))
                  .filter(Boolean)
              );
              peerTds.forEach((td) => {
                updateSummaryCell(td.dataset.absent, hour, val, classe);
              });
            });
          });

          document.querySelectorAll(".select-pot").forEach((sel) => {
            sel.addEventListener("change", (e) => {
              const s = e.target;
              const man = s.parentElement.querySelector(".manual-pot");
              const prevValue = s.dataset.prevValue || "";
              const newValue = s.value.trim();

              // pulizia manual field
              if (newValue) {
                if (man) {
                  man.value = "";
                  man.removeAttribute("value");
                }
              }

              // aggiorna riepilogo
              updateSummaryCell(
                s.dataset.absent,
                s.dataset.hour,
                newValue || "",
                s.dataset.class
              );

              // üîß aggiorna visibilit√† dei menu
              refreshPotVisibilityForHour(s.dataset.hour);

              // üîí Disabilita il docente appena scelto per quell'ora in altri menu
              if (newValue)
                disableChosenSubstituteForHour(newValue, s.dataset.hour);

              // üîì Riabilita il precedente (se non pi√π usato altrove)
              if (prevValue && prevValue !== newValue)
                reenableSubstituteIfFree(prevValue, s.dataset.hour);

              // aggiorna valore precedente
              s.dataset.prevValue = newValue;
            });
          });

          document.querySelectorAll(".manual-pot").forEach((inp) => {
            inp.addEventListener("input", (e) => {
              const i = e.target;
              const sel = i.parentElement.querySelector(".select-pot");
              const val = i.value.trim();
              if (sel) sel.disabled = !!val;
              updateSummaryCell(
                i.dataset.absent,
                i.dataset.hour,
                val,
                i.dataset.class
              );
              refreshPotVisibilityForHour(i.dataset.hour);
            });
          });

          // copia le compresenze automatiche nel riepilogo
          updateSummaryForCompresenze();
        }

        // ====== SALVATAGGIO CSV & PDF ======
        async function uploadCsvToServer(csvContent, filename, remotePath) {
          try {
            const formData = new FormData();
            formData.append("path", remotePath);
            formData.append("filename", filename);
            formData.append("csv_content", csvContent);

            const response = await fetch(phpScriptUrl, {
              method: "POST",
              body: formData,
            });
            const result = await response.json();

            if (response.ok && result.status === "success") {
              showToast(
                `<i class="bi bi-cloud-check-fill me-2"></i> Riepilogo salvato sul server`
              );
            } else {
              showToast(
                `<i class="bi bi-cloud-slash-fill me-2"></i> Errore salvataggio: ${
                  result.message || "sconosciuto"
                }`,
                "alert-danger"
              );
            }
          } catch (error) {
            showToast(
              `<i class="bi bi-cloud-slash-fill me-2"></i> Errore rete salvataggio`,
              "alert-danger"
            );
          }
        }

        // === AGGIORNA riepilogo per compresenze ===
        function updateSummaryForCompresenze() {
          // 1Ô∏è‚É£ Copia tutte le celle .comp-text nel riepilogo
          document.querySelectorAll(".comp-text").forEach((cell) => {
            const row = cell.closest("tr");
            if (!row) return;

            const docente = row
              .querySelector("td:first-child")
              ?.textContent?.trim();
            const hourHeader = cell
              .closest("table")
              ?.querySelectorAll("thead th");
            const colIndex = Array.from(
              cell.parentNode.parentNode.children
            ).indexOf(cell.parentNode);
            const hour =
              hourHeader && hourHeader[colIndex]
                ? hourHeader[colIndex].textContent.trim()
                : null;

            if (docente && hour) {
              const summaryRow = document.querySelector(
                `#summary-grid tbody tr[data-absent="${CSS.escape(docente)}"]`
              );
              if (summaryRow) {
                const summaryCell = summaryRow.querySelector(
                  `td[data-hour="${hour}"]`
                );
                if (summaryCell) {
                  summaryCell.innerHTML = cell.outerHTML; // copia lo stesso contenuto
                  summaryCell.dataset.comp = "1";
                }
              }
            }
          });

          // 2Ô∏è‚É£ Gestione aggiuntiva: docenti di sostegno (mai sostituiti)
          scheduleData.forEach((lez) => {
            if (lez.isSOSTEGNO) {
              const docente = (lez.Docente || "").trim();
              const ora = `${lez.OraInizio}-${lez.OraFine}`;
              const summaryRow = document.querySelector(
                `#summary-grid tbody tr[data-absent="${CSS.escape(docente)}"]`
              );
              if (summaryRow) {
                const summaryCell = summaryRow.querySelector(
                  `td[data-hour="${ora}"]`
                );
                if (summaryCell) {
                  summaryCell.innerHTML =
                    '<div class="comp-text text-center">In compresenza</div>';
                  summaryCell.dataset.comp = "1";
                }
              }
            }
          });
        }

        // ====== SALVATAGGIO CSV & PDF ======
        async function uploadCsvToServer(csvContent, filename, remotePath) {
          try {
            const formData = new FormData();
            formData.append("path", remotePath);
            formData.append("filename", filename);
            formData.append("csv_content", csvContent);

            const response = await fetch(phpScriptUrl, {
              method: "POST",
              body: formData,
            });
            const result = await response.json();

            if (response.ok && result.status === "success") {
              showToast(
                `<i class="bi bi-cloud-check-fill me-2"></i> Riepilogo salvato sul server`
              );
            } else {
              showToast(
                `<i class="bi bi-cloud-slash-fill me-2"></i> Errore salvataggio: ${
                  result.message || "sconosciuto"
                }`,
                "alert-danger"
              );
            }
          } catch (error) {
            showToast(
              `<i class="bi bi-cloud-slash-fill me-2"></i> Errore rete salvataggio`,
              "alert-danger"
            );
          }
        }

        // === AGGIORNA riepilogo per compresenze ===
        function updateSummaryForCompresenze() {
          document.querySelectorAll(".comp-text").forEach((cell) => {
            const row = cell.closest("tr");
            if (!row) return;

            const docente = row
              .querySelector("td:first-child")
              ?.textContent?.trim();
            const hourHeader = cell
              .closest("table")
              ?.querySelectorAll("thead th");
            const colIndex = Array.from(
              cell.parentNode.parentNode.children
            ).indexOf(cell.parentNode);
            const hour =
              hourHeader && hourHeader[colIndex]
                ? hourHeader[colIndex].textContent.trim()
                : null;

            if (docente && hour) {
              const summaryRow = document.querySelector(
                `#summary-grid tbody tr[data-absent="${CSS.escape(docente)}"]`
              );
              if (summaryRow) {
                const summaryCell = summaryRow.querySelector(
                  `td[data-hour="${hour}"]`
                );
                if (summaryCell) {
                  summaryCell.innerHTML = cell.outerHTML; // copia lo stesso contenuto
                  summaryCell.dataset.comp = "1";
                }
              }
            }
          });
        }

        async function exportPdfAndSave() {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF({ orientation: "landscape" });

          const dateEl = document.getElementById("date-input");
          const dateObj =
            dateEl && dateEl.value ? new Date(dateEl.value) : new Date();
          const dataFmt = dateObj.toLocaleDateString("it-IT", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });

          // üîπ Titolo e intestazione
          doc.setFontSize(14);
          doc.setFont("helvetica", "bold");
          doc.text(`Sostituzioni del giorno ${dataFmt}`, 148, 15, {
            align: "center",
          });

          // üîπ Genera la tabella principale dal riepilogo (summary-grid)
          const summaryTable = document.getElementById("summary-grid");
          if (!summaryTable) {
            showToast(
              `<i class="bi bi-exclamation-triangle-fill me-2"></i> Nessuna tabella di riepilogo trovata.`,
              "alert-danger"
            );
            return;
          }

          doc.autoTable({
            html: "#summary-grid",
            startY: 25,
            theme: "grid",
            headStyles: {
              fillColor: [25, 135, 84],
              textColor: [255, 255, 255],
              halign: "center",
              valign: "middle",
            },
            styles: {
              fontSize: 10,
              cellPadding: 3,
              lineColor: [222, 226, 230],
              lineWidth: 0.2,
              textColor: [33, 37, 41],
              halign: "center",
              valign: "middle",
            },
            tableLineWidth: 0.1,
            tableWidth: "auto",
            didDrawPage: (data) => {
              const pageWidth = doc.internal.pageSize.getWidth();
              const pageHeight = doc.internal.pageSize.getHeight();

              // titolo ripetuto
              doc.setFontSize(14);
              doc.setTextColor(33, 37, 41);
              doc.setFont("helvetica", "bold");
              doc.text(
                `Sostituzioni del giorno ${dataFmt}`,
                pageWidth / 2,
                15,
                {
                  align: "center",
                }
              );

              // paginazione centrata
              const pageCount = doc.internal.getNumberOfPages();
              const footer = `Pagina ${data.pageNumber} / ${pageCount}`;
              doc.setFontSize(10);
              doc.setTextColor(150);
              const textWidth = doc.getTextWidth(footer);
              const xCenter = (pageWidth - textWidth) / 2;
              doc.text(footer, xCenter, pageHeight - 10);
            },
            didParseCell: (data) => {
              const txt =
                data.cell.text && data.cell.text[0]
                  ? data.cell.text[0].toLowerCase()
                  : "";

              // Stile specifico per tipo di cella
              if (txt.includes("in compresenza")) {
                data.cell.styles.fontStyle = "italic";
                data.cell.styles.textColor = [108, 117, 125];
              } else if (txt.includes("pot")) {
                data.cell.styles.fontStyle = "bold";
                data.cell.styles.textColor = [108, 117, 125];
              } else if (txt.includes("permesso orario")) {
                data.cell.styles.fontStyle = "italic";
                data.cell.styles.textColor = [13, 202, 240];
              }
            },
            margin: { top: 25, left: 10, right: 10 },
          });

          // üîπ Aggiungi eventuali note
          const notesEl = document.getElementById("notes");
          const notesText = notesEl ? notesEl.value.trim() : "";
          if (notesText) {
            const pageWidth = doc.internal.pageSize.getWidth();
            let y =
              (doc.lastAutoTable && doc.lastAutoTable.finalY
                ? doc.lastAutoTable.finalY
                : 25) + 10;
            doc.setFontSize(9);
            doc.setTextColor(90);
            const wrapped = doc.splitTextToSize(notesText, pageWidth - 28);
            doc.text(wrapped, 14, y);
          }

          // üîπ Salva PDF
          const y_pdf = String(dateObj.getFullYear());
          const m_pdf = String(dateObj.getMonth() + 1).padStart(2, "0");
          const d_pdf = String(dateObj.getDate()).padStart(2, "0");
          const pdfFilename = `riepilogo_sostituzioni_${y_pdf}${m_pdf}${d_pdf}.pdf`;
          doc.save(pdfFilename);

          // üîπ Prepara CSV riepilogo (senza usare sostituzioniMap)
          const rows = [];
          rows.push(["DocenteAssente", "Ora", "Sostituto", "Classe", "Tipo"]);

          // Assenti giornalieri
          dailyAbsent.forEach((teacher) => {
            rows.push([teacher, "GIORNALIERO", "", "", "ASSENZA_GIORNALIERA"]);
          });

          // Assenti orari (tabella riepilogo)
          const summaryRows = document.querySelectorAll(
            "#summary-grid tbody tr"
          );
          summaryRows.forEach((tr) => {
            const docenteAssente =
              tr.dataset.absent || tr.cells[0].innerText.trim();
            tr.querySelectorAll("td[data-hour]").forEach((td) => {
              const ora = td.dataset.hour;
              const html = td.innerHTML.trim();
              if (!html) return;

              let tipo = "SOSTITUZIONE";
              let sostituto = "";
              let classe = "";

              if (html.includes("POT")) tipo = "POTENZIAMENTO";
              else if (html.toLowerCase().includes("permesso"))
                tipo = "PERMESSO_ORARIO";
              else if (html.toLowerCase().includes("in compresenza")) {
                tipo = "COMPRESENZA";
                const m = html.match(/\((.*?)\)/);
                sostituto = m ? m[1] : "";
              } else {
                const parts = html.split("<br>");
                sostituto = parts[0]?.trim() || "";
                classe = parts[1]?.replace(/[()]/g, "").trim() || "";
              }

              rows.push([docenteAssente, ora, sostituto, classe, tipo]);
            });
          });

          const csvContent = rows
            .map((r) => r.map((v) => `"${v}"`).join(","))
            .join("\n");

          // üîπ Upload CSV al server remoto
          const giornoSettimana = abbrevMap[dateObj.getUTCDay()];
          const g_csv = String(dateObj.getDate()).padStart(2, "0");
          const m_csv = String(dateObj.getMonth() + 1).padStart(2, "0");
          const a_csv = dateObj.getFullYear();
          const csvFilename = `sostituzioni_${giornoSettimana}-${g_csv}${m_csv}${a_csv}.csv`;
          const remotePath = `${a_csv}/${m_csv}`;

          try {
            await uploadCsvToServer(csvContent, csvFilename, remotePath);
            showToast(
              `<i class="bi bi-file-earmark-pdf-fill me-2"></i> PDF scaricato e riepilogo salvato con successo.`,
              "alert-success"
            );
          } catch (err) {
            console.error("Errore nel salvataggio CSV remoto:", err);
            showToast(
              `<i class="bi bi-exclamation-triangle-fill me-2"></i> PDF generato, ma errore nel salvataggio remoto.`,
              "alert-warning"
            );
          }
        }

        window.exportPdfAndSave = exportPdfAndSave;

        // üîÅ Ripristino automatico da CSV remoto (versione FIX con log e normalizzazioni)
        async function tryRestoreFromRemote() {
          const selectedDate = dateInput.value;
          if (!selectedDate) return;

          const d = new Date(selectedDate);
          const giornoSettimana = abbrevMap[d.getUTCDay()];
          const g = String(d.getDate()).padStart(2, "0");
          const m = String(d.getMonth() + 1).padStart(2, "0");
          const a = d.getFullYear();

          const fullCsvPath = remoteBaseUrl + csvDataPath;
          const urlSostituzioni = `${fullCsvPath}${a}/${m}/sostituzioni_${giornoSettimana}-${g}${m}${a}.csv`;

          // 1) Verifica esistenza con HEAD (no-cache)
          let exists = false;
          try {
            const head = await fetch(urlSostituzioni, {
              method: "HEAD",
              cache: "no-store",
            });
            exists = head.ok;
          } catch {
            exists = false;
          }
          if (!exists) {
            console.log(
              "[RESTORE] Nessun CSV di ripristino trovato:",
              urlSostituzioni
            );
            return;
          }

          // 2) Conferma utente
          // ‚úÖ Mostra un modale Bootstrap pi√π curato invece del semplice confirm()
          const modalHtml = `
  <div class="modal fade" id="restoreModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content shadow">
        <div class="modal-header bg-primary text-white">
          <h5 class="modal-title"><i class="bi bi-cloud-arrow-down-fill me-2"></i>Ripristino configurazione salvata</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Chiudi"></button>
        </div>
        <div class="modal-body text-center">
          <p class="mb-3">√à stata trovata una configurazione salvata per questa data.</p>
          <p class="text-muted small">Vuoi ripristinare automaticamente le sostituzioni gi√† salvate o procedere con una nuova compilazione?</p>
        </div>
        <div class="modal-footer justify-content-center">
          <button type="button" class="btn btn-outline-secondary" id="skipRestoreBtn" data-bs-dismiss="modal">
            <i class="bi bi-x-circle me-1"></i> Ignora
          </button>
          <button type="button" class="btn btn-success" id="confirmRestoreBtn">
            <i class="bi bi-arrow-clockwise me-1"></i> Ripristina
          </button>
        </div>
      </div>
    </div>
  </div>
`;

          // Elimina modali precedenti (in caso di chiamate multiple)
          document.getElementById("restoreModal")?.remove();
          document.body.insertAdjacentHTML("beforeend", modalHtml);

          const restoreModal = new bootstrap.Modal(
            document.getElementById("restoreModal")
          );
          restoreModal.show();

          // Attendi la scelta dell‚Äôutente
          const userChoice = await new Promise((resolve) => {
            document
              .getElementById("confirmRestoreBtn")
              .addEventListener("click", () => {
                restoreModal.hide();
                resolve(true);
              });

            document
              .getElementById("skipRestoreBtn")
              .addEventListener("click", () => {
                restoreModal.hide();
                resolve(false);
              });
          });

          if (!userChoice) return;

          try {
            console.log("[RESTORE] Scarico CSV:", urlSostituzioni);
            const raw = await fetchCSV(urlSostituzioni);
            // split robusto per CRLF / LF
            const lines = raw
              .split(/\r?\n/)
              .map((s) => s.trim())
              .filter(Boolean);

            // log intestazione + prime righe
            console.log(
              "[RESTORE] Righe totali (incl. intestazione):",
              lines.length
            );
            if (lines.length > 0)
              console.log("[RESTORE] Intestazione CSV:", lines[0]);

            // reset strutture temporanee
            const tmpDaily = new Set();
            const tmpHourly = new Map(); // docente -> Set(ore)
            restoredChoices = new Map(); // `${docente}|${ora}` -> {Sostituto, Classe, Tipo}

            // 3) Parsiamo dalla seconda riga (salta intestazione)
            for (let i = 1; i < lines.length; i++) {
              const line = lines[i];
              if (!line) continue;

              // parsing CSV ‚Äútollerante‚Äù a virgole e virgolette
              const parts = line.match(
                /(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|([^\",]+))/g
              );
              if (!parts) {
                console.warn(`[RESTORE] Riga ${i} non parsabile, salto:`, line);
                continue;
              }
              // normalizza valori rimuovendo virgolette e CR
              const vals = parts.map((v) =>
                v
                  .replace(/^"|"$/g, "")
                  .replace(/""/g, '"')
                  .replace(/\r/g, "")
                  .trim()
              );

              if (vals.length !== 5) {
                console.warn(
                  `[RESTORE] Riga ${i} con ${vals.length} campi (attesi 5), salto:`,
                  vals
                );
                continue;
              }

              let [docente, ora, sostituto, classe, tipo] = vals;
              // log ‚Äúgrezzo‚Äù
              console.log(`[RESTORE][riga ${i}]`, {
                docente,
                ora,
                sostituto,
                classe,
                tipo,
              });

              // 3.a) Assenza giornaliera solo se esplicitamente marcata
              // 3.a) Assenza giornaliera solo se esplicitamente marcata
              if (tipo === "ASSENZA_GIORNALIERA" || ora === "GIORNALIERO") {
                tmpDaily.add(docente);
                console.log(
                  `[RESTORE] Marcato come assente giornaliero: ${docente}`
                );

                // ‚úÖ Cerca anche eventuali righe successive dello stesso docente
                // per popolare le scelte dei sostituti nelle ore
                const relatedRows = lines
                  .slice(i + 1)
                  .map((l) =>
                    l.match(/(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|([^\",]+))/g)
                  )
                  .filter(Boolean)
                  .map((arr) =>
                    arr.map((v) =>
                      v.replace(/^"|"$/g, "").replace(/""/g, '"').trim()
                    )
                  )
                  .filter(
                    (v) =>
                      v[0] === docente &&
                      HOURS.includes(v[1]) &&
                      v[4] !== "ASSENZA_GIORNALIERA"
                  );

                // Se non ci sono righe specifiche, crea placeholder per tutte le ore
                if (relatedRows.length === 0) {
                  HOURS.forEach((h) => {
                    const key = `${docente}|${h}`;
                    if (!restoredChoices.has(key)) {
                      restoredChoices.set(key, {
                        Sostituto: "",
                        Classe: "",
                        Tipo: "ASSENZA_GIORNALIERA",
                      });
                    }
                  });
                } else {
                  // Se ci sono, importa le sostituzioni vere
                  relatedRows.forEach(
                    ([doc, oraRel, sostRel, clsRel, tipoRel]) => {
                      const key = `${doc}|${oraRel}`;
                      restoredChoices.set(key, {
                        Sostituto: sostRel || "",
                        Classe: clsRel || "",
                        Tipo: tipoRel || "SOSTITUZIONE",
                      });
                      console.log(
                        `[RESTORE] Aggiunta sostituzione per ${doc} @ ${oraRel}: ${sostRel}`
                      );
                    }
                  );
                }
              }

              // 3.b) Righe orarie (SOSTITUZIONE / COMPRESENZA / POTENZIAMENTO)
              // normalizza l‚Äôora: potrebbe avere CR o spazi residui
              // 3.b) Righe orarie (SOSTITUZIONE / COMPRESENZA / POTENZIAMENTO)
              ora = ora.replace(/\r/g, "").trim();

              // Se il docente √® gi√† marcato come assente giornaliero, non aggiungerlo mai alle orarie
              if (tmpDaily.has(docente)) {
                console.log(
                  `[RESTORE] ${docente} √® gi√† assente giornaliero ‚Üí salto righe orarie`
                );
                continue;
              }

              if (!HOURS.includes(ora)) {
                console.warn(
                  `[RESTORE] Ora non valida o non in HOURS (${ora}). Riga ${i} scartata.`
                );
                continue;
              }

              // registra ore assenza oraria
              const set = tmpHourly.get(docente) || new Set();
              set.add(ora);
              tmpHourly.set(docente, set);

              // memorizza la scelta per quel blocco (anche se vuota, serve per riepilogo)
              restoredChoices.set(`${docente}|${ora}`, {
                Sostituto: sostituto || "",
                Classe: classe || "",
                Tipo: tipo || "SOSTITUZIONE",
              });
            }

            // 4) LOG riepilogo parsing
            console.log(
              "[RESTORE] Assenti giornalieri ripristinati:",
              Array.from(tmpDaily)
            );
            console.log(
              "[RESTORE] Assenti orari ripristinati:",
              [...tmpHourly.entries()].map(([k, v]) => [k, [...v]])
            );
            console.log("[RESTORE] Scelte ripristinate (keys):", [
              ...restoredChoices.keys(),
            ]);

            // 5) Aggiorna stato globale + UI Sezione 1
            restoring = true;
            dailyAbsent = tmpDaily;
            hourlyAbsent = tmpHourly;

            buildDailyList(searchDailyEl.value);
            buildHourlyTeacherSelect();
            renderHourlySummary();

            // Spunta i checkbox dei giornalieri
            dailyListEl.querySelectorAll(".daily-absent").forEach((cb) => {
              cb.checked = dailyAbsent.has(cb.value);
            });

            // (opz.) Mostra anteprima assenze orarie rilevate (checkbox disabilitati)
            hourlyGridEl.innerHTML = "";
            tmpHourly.forEach((hoursSet, teacher) => {
              const allowed =
                getTeacherHoursOnDate(teacher, selectedDate) || [];
              const validHours = [...hoursSet].filter((h) =>
                allowed.includes(h)
              );
              if (!validHours.length) return;

              const div = document.createElement("div");
              div.className = "mb-2 border-bottom pb-1";
              div.innerHTML = `<div class="fw-bold small mb-1 text-primary">
              <i class="bi bi-person-fill me-1"></i>${teacher}
            </div>`;
              validHours.forEach((h) => {
                div.innerHTML += `<div class="form-check form-check-inline">
                <input class="form-check-input hourly-box" type="checkbox" checked disabled>
                <label class="form-check-label small">${h}</label>
              </div>`;
              });
              hourlyGridEl.appendChild(div);
            });

            restoring = false;

            // 6) Render Sezione 2 con applicazione scelte ripristinate (select/input + riepilogo)
            renderSubstitutionTables(restoredChoices);
            HOURS.forEach(refreshPotVisibilityForHour);

            // 7) LOG di verifica applicazione in UI
            restoredChoices.forEach((val, key) => {
              const [doc, h] = key.split("|");
              const cell = document.querySelector(
                `.table tbody tr td[data-hour="${h}"][data-absent="${CSS.escape(
                  doc
                )}"]`
              );
              console.log(`[RESTORE][UI] cella ${doc} @ ${h}:`, {
                trovata: !!cell,
                scelta: val,
              });
            });

            showToast(
              `<i class="bi bi-arrow-counterclockwise me-2"></i> Ripristino completato`
            );
          } catch (e) {
            console.error("[RESTORE] Errore durante il ripristino:", e);
            showToast(
              `<i class="bi bi-exclamation-octagon-fill me-2"></i> Errore nel ripristino`,
              "alert-danger"
            );
          }
        }

        function refillHourlyUIFromRestoredHourly(
          restoredHourly,
          selectedDate
        ) {
          if (!hourlyGridEl) return;

          // Pulisci il contenitore delle assenze orarie ‚Äúselezionate‚Äù
          hourlyGridEl.innerHTML = "";

          restoredHourly.forEach((hoursSet, teacher) => {
            // mostra solo ore che il docente ha davvero in quel giorno
            const allowed = getTeacherHoursOnDate(teacher, selectedDate) || [];
            const validHours = [...hoursSet].filter((h) => allowed.includes(h));
            if (validHours.length === 0) return;

            const wrapper = document.createElement("div");
            wrapper.className = "mb-2 border-bottom pb-1";
            wrapper.innerHTML = `
            <div class="fw-bold small mb-1 text-primary">
              <i class="bi bi-person-fill me-1"></i>${teacher}
            </div>
          `;

            validHours.forEach((h) => {
              const item = document.createElement("div");
              item.className = "form-check form-check-inline";
              item.innerHTML = `
              <input class="form-check-input hourly-box" type="checkbox" checked disabled>
              <label class="form-check-label small">${h}</label>
            `;
              wrapper.appendChild(item);
            });

            hourlyGridEl.appendChild(wrapper);
          });
        }

        // ====== INIZIALIZZAZIONE ======
        async function initAll() {
          resultsContainer.innerHTML = `<div class="alert alert-warning text-center">Caricamento orario in corso...</div>`;
          await loadOrario();

          // Sezione 1
          buildDailyList();
          buildHourlyTeacherSelect();
          buildHourlyGrid();
          renderHourlySummary();

          // Prova ripristino automatico
          await tryRestoreFromRemote();

          // Primo render sezione 2 (in base a eventuali ripristini)
          renderSubstitutionTables();
        }

        // Ricarica / Ripristina (mantiene data corrente)
        loadBtn.addEventListener("click", async () => {
          await initAll();
        });

        // Cambio data: ricarica tutto
        dateInput.addEventListener("change", async () => {
          // reset selezioni
          dailyAbsent.clear();
          hourlyAbsent.clear();
          await initAll();
        });

        // Avvio
        initAll();
      });

      document.addEventListener("click", async (e) => {
        const btn = e.target.closest("#export-pdf-btn");
        if (!btn) return;

        e.preventDefault();
        const missing = [];

        // üîé Controlla i campi vuoti (select e input manuali)
        document.querySelectorAll("td[data-hour]").forEach((td) => {
          const sel = td.querySelector("select.select-pot");
          const manual = td.querySelector("input.manual-pot");

          // Valori effettivi dei campi
          const selVal = sel && !sel.disabled ? sel.value.trim() : "";
          const manVal = manual && !manual.disabled ? manual.value.trim() : "";

          // reset stile
          td.classList.remove("needs-attention");
          sel && sel.classList.remove("is-invalid");
          manual && manual.classList.remove("is-invalid");

          // Campo manuale o select vuoto ‚Üí segnalazione
          if (
            (sel && !selVal && manual && !manVal) || // entrambi vuoti
            (!sel && manual && !manVal) // solo manuale presente e vuoto
          ) {
            td.classList.add("needs-attention");
            sel && sel.classList.add("is-invalid");
            manual && manual.classList.add("is-invalid");
            missing.push(td);
          }
        });

        // ‚úÖ Se tutto compilato ‚Üí genera subito PDF e salva CSV
        if (missing.length === 0) {
          try {
            console.log("[EXPORT] Avvio generazione PDF + salvataggio CSV...");
            await window.exportPdfAndSave();
          } catch (err) {
            console.error("[EXPORT] Errore durante l‚Äôesportazione:", err);
            window.showToast(
              `<i class="bi bi-exclamation-triangle-fill me-2"></i> Errore durante la generazione del PDF.`,
              "alert-danger"
            );
          }
          return;
        }

        // ‚ö†Ô∏è Se ci sono campi mancanti ‚Üí mostra modale Bootstrap di conferma
        const modalHtml = `
    <div class="modal fade" id="confirmMissingModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-danger">
          <div class="modal-header bg-danger text-white">
            <h5 class="modal-title">
              <i class="bi bi-exclamation-triangle-fill me-2"></i>
              Campi non compilati
            </h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            Alcuni campi (inclusi quelli manuali) non sono stati compilati.<br>
            Vuoi procedere comunque alla generazione del PDF e al salvataggio del riepilogo?
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="reviewMissingBtn">
              <i class="bi bi-arrow-left-circle me-1"></i> Rivedi campi
            </button>
            <button type="button" class="btn btn-danger" id="confirmProceedBtn">
              <i class="bi bi-file-earmark-pdf me-1"></i> Procedi comunque
            </button>
          </div>
        </div>
      </div>
    </div>`;

        // Inserisci la modale nel DOM se non esiste gi√†
        if (!document.getElementById("confirmMissingModal")) {
          document.body.insertAdjacentHTML("beforeend", modalHtml);
        }

        const modalEl = document.getElementById("confirmMissingModal");
        const modal = new bootstrap.Modal(modalEl);
        modal.show();

        // üü° Pulsante "Rivedi campi" ‚Üí evidenzia e scrolla al primo mancante
        modalEl
          .querySelector("#reviewMissingBtn")
          .addEventListener("click", () => {
            modal.hide();
            missing.forEach((td) => {
              td.classList.add("bg-warning-subtle");
              setTimeout(() => td.classList.remove("bg-warning-subtle"), 2500);
            });
            // Scrolla al primo campo non compilato
            missing[0].scrollIntoView({ behavior: "smooth", block: "center" });
          });

        // üî¥ Pulsante "Procedi comunque" ‚Üí rimuove evidenziazioni e genera PDF
        modalEl
          .querySelector("#confirmProceedBtn")
          .addEventListener("click", async () => {
            modal.hide();
            window.scrollTo({ top: 0, behavior: "smooth" });
            // Rimuovi eventuali evidenziazioni
            document.querySelectorAll(".needs-attention").forEach((td) => {
              td.classList.remove("needs-attention", "bg-warning-subtle");
            });
            document
              .querySelectorAll(".is-invalid")
              .forEach((el) => el.classList.remove("is-invalid"));

            try {
              console.log("[EXPORT] Procedo nonostante campi mancanti...");
              await window.exportPdfAndSave();
            } catch (err) {
              console.error("[EXPORT] Errore durante l‚Äôesportazione:", err);
              window.showToast(
                `<i class="bi bi-exclamation-triangle-fill me-2"></i> Errore durante la generazione del PDF.`,
                "alert-danger"
              );
            }
          });
      });
    </script>
    <!-- Bootstrap JS (necessario per il modal e altri componenti dinamici) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>
